<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>択一問題トレーナー</title>
  <style>
    :root {
      --bg: #0b0c10;
      --card: #151922;
      --text: #e8eefc;
      --muted: #9fb0cf;
      --accent: #5da7ff;
      --good: #3cc27a;
      --bad: #ff5d73;
      --border: #243044;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 900px at 70% -10%, #182033, #0b0c10);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "YuGothic", Meiryo, sans-serif;
      line-height: 1.6;
    }
    .wrap {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 5;
      background: rgba(11,12,16,.7);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid var(--border);
    }
    .container {
      width: min(980px, 100%);
      margin: 0 auto;
      padding: 16px clamp(12px, 4vw, 24px);
    }
    h1 {
      margin: 0;
      font-weight: 800;
      letter-spacing: .02em;
      text-align: center; /* タイトルは中央揃え */
      font-size: clamp(20px, 4.6vw, 28px);
    }
    .stats {
      display: flex;
      gap: 12px;
      justify-content: center;
      color: var(--muted);
      font-size: 13px;
      margin-top: 6px;
    }

    main { padding-bottom: 92px; } /* 下部固定バー分の余白 */

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: clamp(14px, 4vw, 22px);
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .meta {
      color: var(--muted);
      font-size: 13px;
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 6px;
      opacity: .9;
    }
    .qid {
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-variant-numeric: tabular-nums;
    }
    .question {
      font-size: clamp(18px, 4.8vw, 22px);
      font-weight: 700;
      margin: 6px 0 12px;
      letter-spacing: .01em;
    }
    .choices {
      display: grid;
      gap: 10px;
    }
    .choice {
      width: 100%;
      text-align: left; /* 選択肢のテキストは左揃え */
      padding: 14px 14px 14px 16px;
      border-radius: 14px;
      background: #0f1522;
      color: var(--text);
      border: 1px solid var(--border);
      font-size: clamp(16px, 4.2vw, 18px);
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px;
      align-items: start;
      cursor: pointer;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
    }
    .choice:hover { transform: translateY(-1px); }
    .choice:active { transform: translateY(0); }
    .choice .key {
      display: inline-grid;
      place-items: center;
      width: 28px;
      height: 28px;
      border-radius: 9px;
      border: 1px solid var(--border);
      color: var(--muted);
      font-weight: 700;
      font-size: 14px;
      margin-top: 1px;
      user-select: none;
      flex: none;
    }
    .choice.correct {
      border-color: rgba(60,194,122,.7);
      box-shadow: 0 0 0 2px rgba(60,194,122,.15) inset;
    }
    .choice.wrong {
      border-color: rgba(255,93,115,.7);
      box-shadow: 0 0 0 2px rgba(255,93,115,.12) inset;
    }

    .feedback {
      margin-top: 14px;
      padding: 12px 14px;
      border-radius: 14px;
      border: 1px dashed var(--border);
      background: #0e1420;
      color: var(--text);
      font-size: 15px;
      white-space: pre-wrap;
    }
    .feedback .ok { color: var(--good); font-weight: 700; }
    .feedback .ng { color: var(--bad); font-weight: 700; }

    .bar {
      position: fixed; /* 下部のボタンは固定 */
      left: 0; right: 0; bottom: 0;
      z-index: 10;
      padding: 10px clamp(12px, 4vw, 24px);
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      background: rgba(11,12,16,.9);
      backdrop-filter: saturate(1.2) blur(8px);
      border-top: 1px solid var(--border);
    }
    .bar .inner {
      width: min(980px, 100%);
      margin: 0 auto;
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 10px;
      align-items: center;
    }
    .bar .progress {
      color: var(--muted);
      font-size: 13px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .btn {
      appearance: none;
      border: 1px solid var(--border);
      background: #0f1724;
      color: var(--text);
      padding: 12px 16px;
      border-radius: 12px;
      font-weight: 700;
      font-size: 15px;
      cursor: pointer;
      transition: transform .08s ease, background .15s ease, border-color .15s ease;
    }
    .btn.primary {
      background: linear-gradient(180deg, #2a66ff, #1a48c7);
      border-color: transparent;
    }
    .btn.danger {
      background: linear-gradient(180deg, #e04b63, #b23345);
      border-color: transparent;
    }
    .btn:active { transform: translateY(1px); }
    .btn[disabled] { opacity: .6; cursor: not-allowed; transform: none; }
    .ghost { opacity: .75; }
    .hidden { display: none !important; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="container">
        <h1>択一問題トレーナー</h1>
        <div class="stats">
          <span id="totalInfo">読み込み中…</span>
        </div>
      </div>
    </header>

    <main>
      <div class="container">
        <div class="card" id="qaCard" aria-live="polite">
          <div class="meta"><span class="qid" id="qid">-</span><span id="metaYear"></span></div>
          <div class="question" id="question">読み込み中…</div>
          <div class="choices" id="choices"></div>
          <div class="feedback hidden" id="feedback"></div>
        </div>
      </div>
    </main>

    <div class="bar">
      <div class="inner">
        <div class="progress mono" id="progress">—</div>
        <button class="btn" id="nextBtn">次へ</button>
        <button class="btn danger" id="resetBtn">リセット</button>
      </div>
    </div>
  </div>

  <script>
  // ===== Utility: CSV parser (handles quotes) =====
  function parseCSV(text) {
    const rows = [];
    let i=0, field='', row=[], inQuotes=false;
    while (i < text.length) {
      const ch = text[i];
      if (inQuotes) {
        if (ch === '"') {
          if (text[i+1] === '"') { field += '"'; i+=2; continue; }
          inQuotes = false; i++; continue;
        }
        field += ch; i++; continue;
      } else {
        if (ch === '"') { inQuotes = true; i++; continue; }
        if (ch === ',') { row.push(field); field=''; i++; continue; }
        if (ch === '\n') { row.push(field); rows.push(row); field=''; row=[]; i++; continue; }
        if (ch === '\r') { i++; continue; }
        field += ch; i++; continue;
      }
    }
    row.push(field); rows.push(row);
    return rows;
  }

  // ===== Normalize helpers =====
  const abc = ['a','b','c','d','e','f','g','h'];
  const full2half = s => s.replace(/[Ａ-Ｚａ-ｚ０-９．－（）]/g, c =>
    String.fromCharCode(c.charCodeAt(0) - 0xFEE0)
  ).replace(/[‐－―–—]/g,'-').replace(/[，、｡。．]/g, m => ({'，':',','、':',','｡':'.','。':'.','．':'.'}[m]));

  function normalizeKey(raw, idxFallback=0) {
    if (!raw) return abc[idxFallback] || 'a';
    let s = full2half(String(raw)).trim().toLowerCase();
    s = s.replace(/^answer[:：\s]*/,'').trim();
    // map 1-8 → a-h
    if (/^[1-8]$/.test(s)) return abc[parseInt(s,10)-1];
    // remove trailing/leading like "a)" "a." "(a)"
    const m = s.match(/[a-h]/);
    return m ? m[0] : (abc[idxFallback] || 'a');
  }

  function parseChoices(str) {
    const out = [];
    const s = full2half(String(str || '')).trim();
    if (!s) return out;
    // Try to split by common delimiters
    let parts = s.split(/\s*\|\s*|\s*;+\s*|\s*\/\s*|\s*\/\/\s*|\s*｜\s*|\s*；\s*/);
    if (parts.length === 1) {
      // try newline
      parts = s.split(/\r?\n/);
    }
    // If still one, try to extract by label regex like "a) xxx"
    if (parts.length === 1) {
      const re = /(?:^|\s)(([a-h1-8])[\)\.．、]\s*)([^]+?)(?=(?:\s+[a-h1-8][\)\.．、]\s)|$)/ig;
      let m; parts = [];
      while ((m = re.exec(s)) !== null) {
        parts.push(m[2] + ') ' + m[3].trim());
      }
      if (parts.length === 0) parts = [s]; // fallback
    }
    parts = parts.filter(p => p && p.trim().length).map(p => p.trim());

    let auto = 0;
    for (const raw of parts) {
      // optional leading key
      let key = null, text = raw;
      const m = raw.match(/^\s*([a-h1-8])[\)\.．、]\s*(.*)$/i);
      if (m) { key = normalizeKey(m[1]); text = m[2].trim(); }
      else { key = abc[auto]; text = raw; }
      auto++;
      out.push({ key, text });
    }
    return out;
  }

  // ===== State =====
  let all = [];                 // all questions
  let pool = [];                // candidates (exclude answered-correct)
  let solved = new Set();       // ids solved correctly
  let current = null;           // current question object
  let lastId = null;            // avoid immediate repeat
  let seenCount = 0;

  function idOf(q) { return `${q.year || ''}-${q.number || ''}-${(q.question||'').slice(0,24)}`; }

  // ===== UI refs =====
  const qidEl = document.getElementById('qid');
  const metaYearEl = document.getElementById('metaYear');
  const qEl = document.getElementById('question');
  const choicesEl = document.getElementById('choices');
  const feedbackEl = document.getElementById('feedback');
  const totalInfoEl = document.getElementById('totalInfo');
  const progressEl = document.getElementById('progress');
  const nextBtn = document.getElementById('nextBtn');
  const resetBtn = document.getElementById('resetBtn');

  nextBtn.addEventListener('click', nextQuestion);
  resetBtn.addEventListener('click', doReset);

  function shuffle(arr) {
    for (let i=arr.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function pickRandom() {
    if (pool.length === 0) return null;
    if (pool.length === 1) return pool[0];
    let q = null, guard = 0;
    do {
      q = pool[Math.floor(Math.random()*pool.length)];
      guard++;
    } while (q._id === lastId && guard < 10);
    return q;
  }

  function render(q) {
    feedbackEl.classList.add('hidden');
    feedbackEl.innerHTML = '';
    qidEl.textContent = q.number ? `No.${q.number}` : '—';
    metaYearEl.textContent = q.yearDisplay || q.year || '';
    qEl.textContent = q.question || '(問題文なし)';

    // build choices
    choicesEl.innerHTML = '';
    const frag = document.createDocumentFragment();
    const items = q._choices.slice(); // copy
    // show in a stable order (a..h)
    items.sort((a,b) => a.key.localeCompare(b.key, 'ja'));
    items.forEach((cObj) => {
      const btn = document.createElement('button');
      btn.className = 'choice';
      btn.setAttribute('data-key', cObj.key);
      btn.innerHTML =
        `<span class="key">${cObj.key}</span><span class="txt">${cObj.text}</span>`;
      btn.addEventListener('click', () => checkAnswer(q, cObj.key, btn));
      frag.appendChild(btn);
    });
    choicesEl.appendChild(frag);

    // update bar
    totalInfoEl.textContent = `全${all.length}問中 / 正解済 ${solved.size}問`;
    progressEl.textContent = `出題回数 ${seenCount}　｜　正解 ${solved.size}　｜　残り ${Math.max(pool.length - (current ? 1 : 0), 0)}`;
  }

  function checkAnswer(q, key, btnEl) {
    // already answered? do nothing
    if (!current || q._answered) return;
    q._answered = true;

    const correctKey = q._correct;
    const isOk = key === correctKey;

    // mark selected
    btnEl.classList.add(isOk ? 'correct' : 'wrong');

    // mark correct choice for visibility
    const nodes = choicesEl.querySelectorAll('.choice');
    nodes.forEach(n => {
      const k = n.getAttribute('data-key');
      if (k === correctKey) n.classList.add('correct');
    });

    // feedback
    let fb = '';
    if (isOk) {
      fb = `<span class="ok">正解！</span>`;
      // remove from pool & register solved
      solved.add(q._id);
      pool = pool.filter(x => x._id !== q._id);
    } else {
      const label = correctKey;
      fb = `<span class="ng">不正解　正解は${label}</span>`;
    }
    if (q.explanation) {
      fb += `\n解説：${q.explanation}`;
    }
    feedbackEl.innerHTML = fb;
    feedbackEl.classList.remove('hidden');

    // update footer stats
    totalInfoEl.textContent = `全${all.length}問中 / 正解済 ${solved.size}問`;
    progressEl.textContent = `出題回数 ${seenCount}　｜　正解 ${solved.size}　｜　残り ${pool.length}`;
  }

  function nextQuestion() {
    if (pool.length === 0) {
      // try to keep showing the last card but announce completion
      qEl.textContent = '🎉 全て正解しました！　「リセット」で再開できます。';
      choicesEl.innerHTML = '';
      feedbackEl.classList.add('hidden');
      progressEl.textContent = `出題回数 ${seenCount}　｜　正解 ${solved.size}　｜　残り 0`;
      return;
    }
    const q = pickRandom();
    if (!q) return;
    current = q;
    lastId = q._id;
    seenCount++;
    render(q);
  }

  function doReset() {
    solved.clear();
    pool = all.slice();
    seenCount = 0;
    lastId = null;
    current = null;
    shuffle(pool);
    nextQuestion();
  }

  function hydrate(rows) {
    if (!rows.length) throw new Error('CSVが空です');
    // header map
    const head = rows[0].map(h => full2half(h).trim());
    const idx = Object.fromEntries(head.map((h, i) => [h.toLowerCase(), i]));
    const need = ["year","yeardisplay","number","question","image_placeholder","choices","correct","explanation"];
    for (const k of need) if (!(k in idx)) console.warn('列が見つかりませんでした:', k);

    const list = [];
    for (let r = 1; r < rows.length; r++) {
      const row = rows[r];
      if (!row || row.length === 0) continue;
      const item = {
        year: row[idx.year] ?? '',
        yearDisplay: row[idx.yeardisplay] ?? '',
        number: row[idx.number] ?? '',
        question: row[idx.question] ?? '',
        image_placeholder: row[idx.image_placeholder] ?? '',
        choices: row[idx.choices] ?? '',
        correct: row[idx.correct] ?? '',
        explanation: row[idx.explanation] ?? ''
      };

      const _choices = parseChoices(item.choices);
      const fallbackKey = _choices.length ? _choices[0].key : 'a';
      const _correct = normalizeKey(item.correct || '', abc.indexOf(fallbackKey));

      // if choices had no labels, normalize to a.. in order
      if (_choices.length) {
        const mapByOrder = new Map();
        _choices.forEach((c, i) => { if (!c.key) c.key = abc[i]; mapByOrder.set(c.key, c); });
        // ensure the correct key exists; if not, map number to index
        if (!mapByOrder.has(_correct) && /^[1-8]$/.test(item.correct)) {
          const idxNum = parseInt(item.correct,10)-1;
          if (_choices[idxNum]) _choices[idxNum].key = abc[idxNum];
        }
      }

      const q = {
        ...item,
        _id: `${(item.year||'').trim()}-${(item.number||'').toString().trim()}-${(item.question||'').slice(0,24)}`,
        _choices,
        _correct,
        _answered: false
      };
      // skip rows without question or choices
      if (!q.question || !_choices.length) continue;
      list.push(q);
    }
    return list;
  }

  async function boot() {
    try {
      const res = await fetch('mondai4-1.csv', { cache: 'no-store' });
      if (!res.ok) throw new Error('CSVの読み込みに失敗しました');
      const text = await res.text();
      const rows = parseCSV(text);
      all = hydrate(rows);
      if (!all.length) throw new Error('有効な問題が見つかりませんでした');
      // initial pool excludes solved (none) and is shuffled
      pool = all.slice();
      shuffle(pool);
      totalInfoEl.textContent = `全${all.length}問中 / 正解済 0問`;
      nextQuestion();
    } catch (e) {
      qEl.textContent = '読み込みエラー：' + e.message;
      choicesEl.innerHTML = '';
      console.error(e);
    }
  }

  boot();
  </script>
</body>
</html>
