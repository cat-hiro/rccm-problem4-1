<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RCCM 問題4-1</title>
<style>
  :root{
    --brand:#1976d2; --brand-600:#1565c0;
    --ok:#2e7d32; --ng:#d32f2f;
    --card:#ffffff; --bg:#f5f7fb; --text:#1d2630; --muted:#5b6b7a; --border:#e5e9f1;
    --shadow:0 6px 18px rgba(24,39,75,0.12); --radius:14px;
  }
  html,body{height:100%}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,
        "Hiragino Sans","Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic UI","YuGothic","Meiryo",Arial,sans-serif;
        background:var(--bg); color:var(--text);}
  .appbar{position:sticky;top:0;z-index:5;background:var(--brand);color:#fff;
    padding:14px 20px calc(env(safe-area-inset-top) + 14px);box-shadow:var(--shadow);text-align:center;font-weight:700;}
  .wrap{max-width:980px;margin:24px auto 120px;padding:0 16px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:var(--radius);box-shadow:var(--shadow);padding:18px}
  .meta{font-size:12px;color:var(--muted);margin-bottom:8px}
  .qtext{font-size:18px;line-height:1.7;margin:8px 0 14px;word-break:break-word}
  .qimg{display:block;max-width:100%;height:auto;border:1px solid var(--border);border-radius:10px;margin:10px 0 6px}
  .opt{display:block;width:100%;text-align:left;background:#fff;border:1px solid var(--border);border-radius:12px;
    padding:14px 16px;margin:10px 0;font-size:16px;line-height:1.6;cursor:pointer;
    transition:transform .02s ease,border-color .15s ease,background .15s ease}
  .opt:active{transform:scale(.998)}
  .opt.correct{border-color:rgba(46,125,50,.4);background:rgba(76,175,80,.06)}
  .opt.wrong{border-color:rgba(211,47,47,.4);background:rgba(244,67,54,.06)}
  .opt .label{display:inline-block;min-width:1.6em;font-weight:700;color:var(--muted)}
  .feedback{margin-top:10px;font-size:15px;padding:10px 12px;border-left:4px solid var(--border);color:var(--muted);white-space:pre-wrap}
  .feedback.ok{border-left-color:var(--ok);color:var(--ok)}
  .feedback.ng{border-left-color:var(--ng);color:var(--ng)}
  .notes{color:var(--muted);font-size:12px;margin-top:12px}
  .notes li{margin:4px 0}
  .bottom{position:fixed;left:0;right:0;bottom:0;z-index:10;background:#fff;border-top:1px solid var(--border);
    padding:10px 12px calc(10px + env(safe-area-inset-bottom));display:flex;gap:12px;justify-content:center}
  .btn{flex:1 1 0;max-width:520px;padding:14px 10px;border-radius:12px;border:none;font-weight:700;font-size:16px;cursor:pointer;color:#fff}
  .btn-primary{background:var(--brand)} .btn-primary:active{background:var(--brand-600)}
  .btn-danger{background:var(--ng)} .btn-danger:active{background:#b71c1c}
</style>
</head>
<body>
  <div class="appbar">RCCM 問題4-1</div>

  <div class="wrap">
    <div class="card" id="card">
      <div class="meta" id="meta">No.- / 年度 -</div>
      <div class="qtext" id="qtext">読み込み中…</div>
      <img id="qimg" class="qimg" hidden alt="問題画像" />
      <div id="options"></div>
      <div class="feedback" id="feedback" hidden></div>

      <ul class="notes">
        <li>出題はランダム / 正解した問題は「リセット」まで再出題しません。</li>
        <li>タップで即判定。不正解時は「正解は a/b/c/d」+ 解説を表示します。</li>
        <li>出題数は無制限です。</li>
      </ul>
    </div>
  </div>

  <div class="bottom">
    <button class="btn btn-primary" id="nextBtn">次の問題</button>
    <button class="btn btn-danger" id="resetBtn">リセット</button>
  </div>

<script>
(() => {
  const CSV_PATH = 'mondai4-1.csv'; // リポジトリ直下
  const answeredCorrectIds = new Set();
  let allItems = [];
  let current = null;

  const labelOf = i => ['a','b','c','d','e','f','g','h'][i] || String(i+1);

  init();

  async function init(){
    try{
      const text = await fetchCsvWithAutoEncoding(CSV_PATH);
      const rows = robustCsvParse(text); // [{...}]
      allItems = rows.map((r, idx) => normalizeRecord(r, idx)).filter(Boolean);
      nextQuestion();
    }catch(e){
      showText('読み込みエラー: ' + e.message);
      console.error(e);
    }
  }

  // ===== エンコーディング自動判定：UTF-8 → ダメなら Shift_JIS =====
  async function fetchCsvWithAutoEncoding(path){
    const res = await fetch(path, {cache:'no-store'});
    if(!res.ok) throw new Error(`CSV fetch failed: ${res.status}`);
    const buf = await res.arrayBuffer();

    const decUtf8 = new TextDecoder('utf-8', {fatal:false});
    let textUtf8 = decUtf8.decode(buf);
    const badUtf8 = (textUtf8.match(/\uFFFD/g) || []).length;

    // Shift_JIS で再デコードして「�」が減るなら採用
    let textSjis = '';
    try {
      const decSjis = new TextDecoder('shift_jis', {fatal:false});
      textSjis = decSjis.decode(buf);
    } catch(_) {}

    const badSjis = textSjis ? (textSjis.match(/\uFFFD/g) || []).length : Infinity;

    if (badSjis < badUtf8) return textSjis;
    return textUtf8;
  }

  // ===== CSVパース（引用符・改行対応） + ヘッダー名ゆらぎ吸収 =====
  function robustCsvParse(src){
    src = src.replace(/\r\n?/g, '\n');
    if(!src.trim()) return [];
    // 先頭行（ヘッダー）
    let p = 0, inQ = false, header = '';
    while(p < src.length){
      const ch = src[p++];
      if(ch === '"'){ inQ = !inQ; header += ch; }
      else if(ch === '\n' && !inQ) break;
      else header += ch;
    }
    const headerCells = splitCsvLine(header);
    const canon = s => s.toLowerCase().replace(/^\uFEFF/,'').replace(/[^a-z0-9_]/g,'');
    const wanted = {
      year:['year'],
      yearDisplay:['yeardisplay','yeardisp','yeardsp'],
      number:['number','no'],
      question:['question','q','problem'],
      image_placeholder:['image_placeholder','image','img','imgplaceholder'],
      choices:['choices','options','opts'],
      correct:['correct','answer','ans'],
      explanation:['explanation','exp','comment','note']
    };
    const hmap = {};
    headerCells.forEach((h,i)=>{
      const c = canon(h);
      hmap[i] = c;
    });

    // 本文を行単位で切り出し
    const lines = [];
    let cur = '', q = false;
    for(; p < src.length; p++){
      const ch = src[p];
      if(ch === '"'){
        q = !q; cur += ch;
      }else if(ch === '\n' && !q){
        lines.push(cur); cur = '';
      }else{
        cur += ch;
      }
    }
    if(cur) lines.push(cur);

    const records = lines.map(line => {
      const cells = splitCsvLine(line);
      const obj = {};
      cells.forEach((val, idx) => {
        obj[hmap[idx] || ('col'+idx)] = val;
      });
      // 正規キーに寄せる
      const out = {};
      for(const key in wanted){
        for(const alias of wanted[key]){
          const hit = Object.keys(obj).find(k => k===alias);
          if(hit){ out[key] = obj[hit]; break; }
        }
        if(out[key] == null) out[key] = '';
      }
      return out;
    });
    return records;
  }

  // 1行のセル分割（"で囲まれた中の , と "" を扱う）
  function splitCsvLine(line){
    const cells = []; let c = '', q = false;
    for(let i=0;i<line.length;i++){
      const ch = line[i];
      if(ch === '"'){
        if(q && line[i+1] === '"'){ c+='"'; i++; }
        else q = !q;
      }else if(ch === ',' && !q){
        cells.push(c); c='';
      }else{
        c += ch;
      }
    }
    cells.push(c);
    // 外側の引用符を剥がす
    return cells.map(s=>{
      s = s.trim();
      if(s.startsWith('"') && s.endsWith('"')) s = s.slice(1,-1).replace(/""/g,'"');
      return s;
    });
  }

  // ===== レコード正規化 =====
  function normalizeRecord(r, idx){
    const qText = (r.question || '').trim();
    if(!qText) return null;

    const explanation = (r.explanation || '').trim();
    const imgRaw = (r.image_placeholder || '').trim();

    // 選択肢
    let choicesRaw = (r.choices || '').trim();
    let choices;
    try{
      choices = JSON.parse(choicesRaw);
      if(!Array.isArray(choices)) throw 0;
    }catch{
      // セミコロン / パイプ / 全角パイプなどの区切りも許容
      choices = choicesRaw.split(/\s*[;｜|]\s*/);
    }
    choices = choices.filter(s => String(s).trim().length>0).slice(0,8);

    // 正解
    const ci = normalizeCorrect(r.correct, choices.length);

    // 表示テキスト整形（先頭の「a.」「ａ．」等を除去）
    const strip = s => String(s).replace(/^\s*[a-hａ-ｈＡ-Ｈ]\s*[\.．、)）]\s*/i,'').trim();

    // isCorrect を付与してからシャッフル
    let options = choices.map((t,i)=>({ text: strip(t), isCorrect: i===ci }));
    options = shuffle(options);

    // 画像：Base64/データURL/拡張子なしBase64 に対応
    let imgSrc = '';
    if (imgRaw) {
      if (/^data:image\//i.test(imgRaw)) imgSrc = imgRaw;
      else if (/^[A-Za-z0-9+/=]{100,}$/.test(imgRaw)) imgSrc = 'data:image/png;base64,' + imgRaw;
      else if (/^https?:\/\//i.test(imgRaw)) imgSrc = imgRaw;
    }

    return {
      id: (r.year || '') + '-' + (r.number || idx),
      year: String(r.yearDisplay || r.year || '').trim(),
      number: String(r.number || '').trim(),
      question: qText,
      options,
      explanation,
      image: imgSrc
    };
  }

  function normalizeCorrect(v, len){
    if(v==null) return 0;
    let s = String(v).trim();
    s = s.replace(/[ａ-ｚＡ-Ｚ]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));
    s = s.replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0) - 0xFEE0));
    const m = s.match(/^[a-h]/i);
    if(m) return m[0].toLowerCase().charCodeAt(0) - 97;
    if(/^\d+$/.test(s)){
      const n = parseInt(s,10);
      if(n>=1 && n<=len) return n-1;
      if(n>=0 && n<len)   return n;
    }
    return 0;
  }

  function shuffle(arr){
    const a = arr.slice();
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }

  // ===== 出題・描画 =====
  function nextQuestion(){
    const pool = allItems.filter(q => !answeredCorrectIds.has(q.id));
    if(pool.length === 0){
      showText('全ての問題に正解しました！「リセット」で再開できます。');
      renderMeta('-', '-');
      document.getElementById('qimg').hidden = true;
      return;
    }
    current = pool[Math.floor(Math.random()*pool.length)];
    renderQuestion(current);
  }

  function renderQuestion(q){
    renderMeta(q.number || '-', q.year || '-');
    document.getElementById('qtext').textContent = q.question;

    const imgEl = document.getElementById('qimg');
    if(q.image){
      imgEl.src = q.image; imgEl.hidden = false;
    }else{
      imgEl.hidden = true;
    }

    const box = document.getElementById('options');
    box.innerHTML = '';
    document.getElementById('feedback').hidden = true;

    q.options.forEach((opt, idx) => {
      const btn = document.createElement('button');
      btn.className = 'opt';
      btn.innerHTML = `<span class="label">${labelOf(idx)}.</span> ${escapeHtml(opt.text)}`;
      btn.addEventListener('click', () => onAnswer(q, idx));
      box.appendChild(btn);
    });
  }

  function renderMeta(no, year){
    document.getElementById('meta').textContent = `No.${no} / ${year}`;
  }

  function onAnswer(q, chosenIdx){
    const optsEl = [...document.querySelectorAll('.opt')];
    const correctIdx = q.options.findIndex(o => o.isCorrect);
    const feedback = document.getElementById('feedback');

    optsEl.forEach((el,i)=>{
      el.disabled = true;
      if(i===correctIdx) el.classList.add('correct');
      if(i===chosenIdx && i!==correctIdx) el.classList.add('wrong');
    });

    if(chosenIdx === correctIdx){
      feedback.className = 'feedback ok';
      feedback.hidden = false;
      feedback.textContent = '正解！';
      answeredCorrectIds.add(q.id);
    }else{
      feedback.className = 'feedback ng';
      feedback.hidden = false;
      const correctLabel = labelOf(correctIdx);
      const explain = q.explanation ? `\n解説：${q.explanation}` : '';
      feedback.textContent = `不正解。正解は ${correctLabel}。${explain}`;
    }
  }

  function showText(msg){
    document.getElementById('qtext').textContent = msg;
    document.getElementById('options').innerHTML = '';
    document.getElementById('feedback').hidden = true;
  }

  function escapeHtml(s){
    return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
  }

  // ===== UI =====
  document.getElementById('nextBtn').addEventListener('click', nextQuestion);
  document.getElementById('resetBtn').addEventListener('click', () => {
    answeredCorrectIds.clear(); nextQuestion();
  });

})();
</script>
</body>
</html>

